{% extends "layout.html" %}

{% block content %}

<body>
<div>
    <div id="gender-controls">
      <p class="genderButtons">
        <input checked id="nGender-male" name="gender" style="width: 30px;" type="radio" value="1">
        <label style=" margin-right: 50px;" for="nGender-male">Male</label>

        <input id="nGender-female" name="gender" style="width: 30px;" type="radio" value="0">
        <label for="nGender-female">Female</label>
      </p>
    </div>
  </div>

<style>
@import url('https://fonts.googleapis.com/css?family=Montserrat');

body {
    font: 22px sans-serif;
    color: black;
    }

    .axis path,
    .axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
    stroke-width:4.5px;
    }

    div {
    margin: auto;
    padding: 20px 15px;

    }

    .ageslider, .genderButtons {
    font: 28px sans-serif;
    margin-left:130px;
    margin-right:150px;
    height: 30px;
    float: left;
    text-align: center;
    font-weight: bold;
    }

    .ageslider {
    margin-right: 30px;
    }


    .overlay {
    fill: none;
    pointer-events: all;
    }

    .focusMarkers circle {
    fill: none;
    stroke: #0C6CD4;
    }


    .legend {
    padding: 5px;
    font: 20px sans-serif;
    background: yellow;
    box-shadow: 2px 2px 1px #888;
    }


    .brush .extent {
    stroke: #fff;
    fill-opacity: .125;
    shape-rendering: crispEdges;
    }


    .path_prob {
    fill:none;
    stroke:#0C6CD4;
    stroke-width:4.5px;
    }

    body, html, p, label, input{
        font-family: 'Montserrat', sans-serif;
    }
  </style>

  <script>

  d3.csv('.static/data/attendence_grade.csv', (error, dataValue) => {
      let grade_values = [];
      const intercept = -7.3381
      const gradebeta = .0953
      const pdata = ['prob'];
      let default_is_male = 1
      let defaultGenderText = "male";
      let data = [];
      d3.select("#nGender-value").text(defaultGenderText);
      d3.select("#nGender").property("value", default_is_male);

      data = buildData(default_is_male);

      function buildData(gender) {
        const sex = gender === 0 ? 'F' : 'M';
        let maleCount = 0;
        let femaleCount = 0;
        dataValue.forEach(element => {
          if (element.Sex === 'M') {
            maleCount++;
          } else {
            femaleCount++;
          }
          if (element.Sex === sex) {
            grade_values.push(element.Grade);
          }
        });
        const genderbeta = gender === 0 ? femaleCount / dataValue.length : maleCount / dataValue.length;
        grade_values = grade_values.sort((a, b) => a - b);
        data = []
        grade_values.forEach(function (element) {
          var prob_calc = 1 / (1 + Math.exp(-(intercept + gradebeta * element + genderbeta * gender)))
          var grade_value_object = {
            'grade': element,
            'prob': prob_calc
          };
          data.push(grade_value_object);
        });
        return data;
      };

      // Enable mode buttons.
      d3.selectAll("#gender-controls input[name=gender]").on("change", function () {
        default_is_male = +this.value;
        if (default_is_male == 1) {
          defaultGenderText = "male"
        } else {
          defaultGenderText = "female"
        }
        update(default_is_male);
      });

      // update the elements
      function update(nAge, nGender) {
        d3.select("#nGender-value").text(defaultGenderText);
        d3.select("#nGender").property("value", default_is_male);
        data = buildData(default_is_male);
        xmain.domain(d3.extent(data, function (d) { return d.grade; }));

        y_axis_range_max_range = d3.extent(data, function (d) { return d.prob; });
        y_axis_range_min_range = d3.extent(data, function (d) { return d.prob; });
        y_axis_range_max = Math.min(1, y_axis_range_max_range[1] * 1.1)
        y_axis_range_min = y_axis_range_min_range[0] * .8
        ymain.domain([y_axis_range_min, y_axis_range_max]);

        xbrush.domain(xmain.domain());
        ybrush.domain(ymain.domain());

        focus.selectAll("path.focusdata").attr("d", function (prob_when) {
          return areaMain(prob_when)(data);
        });

        context.selectAll("path.contextdata").attr("d", function (prob_when) {
          return areaBrush(prob_when)(data);
        });

        focus.select(".x.axis").call(xAxis);
        focus.select(".y.axis").call(yAxis);

      }

      // svg helpers
      function brushed() {
        xmain.domain(brush.empty() ? xbrush.domain() : brush.extent());

        var max = d3.max(data.map(function (d) { return d.prob; }));

        if (typeof max === "undefined") {
          ymain.domain(brush.empty() ? ybrush.domain() : y_axis_range);
        } else {
          y_axis_range = [0, Math.min(max * 1.1, 1)]
          ymain.domain(brush.empty() ? ybrush.domain() : y_axis_range);
        }

        focus.selectAll("path.focusdata").attr("d", function (prob_when) {
          return areaMain(prob_when)(data);
        });

        focus.select(".x.axis").call(xAxis);
        focus.select(".y.axis").call(yAxis);
      }


      var areaMain = function (prob_when) {
        return d3.svg.line()
          .interpolate("monotone")
          .x(function (d) {
            return xmain(d.grade);
          })

          .y(function (d) {
            return ymain(d[prob_when]);
          });
      };


      var areaBrush = function (prob_when) {
        return d3.svg.line()
          .interpolate("monotone")
          .x(function (d) { return xbrush(d.grade); })

          .y(function (d) {
            return ybrush(d[prob_when]);
          });
      };



      var margin = { top: 10, right: 60, bottom: 200, left: 150 },
        margin2 = { top: 520, right: 60, bottom: 30, left: 150 },
        width = 1200 - margin.left - margin.right,
        height = 680 - margin.top - margin.bottom,
        height2 = 680 - margin2.top - margin2.bottom;


      var xmain = d3.scale.linear().range([0, width]);
      var xbrush = d3.scale.linear().range([0, width]);

      var ymain = d3.scale.linear().range([height, 0]);
      var ybrush = d3.scale.linear().range([height2, 0]);

      var xAxis = d3.svg.axis().scale(xmain).orient("bottom");
      var xAxis2 = d3.svg.axis().scale(xbrush).orient("bottom");

      var yAxis = d3.svg.axis()
        .scale(ymain)
        .orient("left");

      var brush = d3.svg.brush()
        .x(xbrush)

        .on("brush", brushed);

      var svg = d3.select("body").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);

      var legendRectSize = 18;
      var legendSpacing = 4;

      svg.append("defs").append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("width", width)
        .attr("height", height);

      var color_hash = {
        0: ["prob", "#0C6CD4", "Grade Probability"]
      }

      // add legend   
      var legend = svg.append("g")
        .attr("class", "legend")
        .attr("height", 100)
        .attr("width", 100)
        .attr('transform', 'translate(-630,20)')


      legend.selectAll('rect')
        .data(pdata)
        .enter()
        .append("rect")
        .attr("x", width - 95)
        .attr("y", function (d, i) { return i * 30; })
        .attr("width", 20)
        .attr("height", 20)
        .style("fill", function (d) {
          var color = color_hash[pdata.indexOf(d)][1];
          return color;
        })

      legend.selectAll('text')
        .data(pdata)
        .enter()
        .append("text")
        .attr("x", width - 65)
        .attr("y", function (d, i) { return i * 30 + 15; })
        .text(function (d) {
          var text = color_hash[pdata.indexOf(d)][2];
          return text;
        });


      var focus = svg.append("g")
        .attr("class", "focus")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      var context = svg.append("g")
        .attr("class", "context")
        .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

      xmain.domain(d3.extent(data, function (d) { return d.grade; }));

      y_axis_range_max_range = d3.extent(data, function (d) { return d.prob; });
      y_axis_range_min_range = d3.extent(data, function (d) { return d.prob; });
      y_axis_range_max = Math.min(1, y_axis_range_max_range[1] * 1.1)
      y_axis_range_min = y_axis_range_min_range[0] * .8
      ymain.domain([y_axis_range_min, y_axis_range_max]);


      xbrush.domain(xmain.domain());
      ybrush.domain(ymain.domain());

      focus.selectAll('path')
        .data(pdata)
        .enter()
        .append('path')
        .attr('clip-path', 'url(#clip)')
        .attr('d', function (prob_when) {
          return areaMain(prob_when)(data);
        })
        .attr('class', function (prob_when) {
          return "path_" + prob_when + " focusdata";
        });

      context.selectAll('path')
        .data(pdata)
        .enter()
        .append('path')
        .attr('clip-path', 'url(#clip)')
        .attr('fill', 'none')
        .attr('d', function (prob_when) {
          return areaBrush(prob_when)(data);
        })
        .attr('class', function (prob_when) {
          return "path_" + prob_when + " contextdata";
        });

      focus.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis)
        .append("text")
        .attr("class", "x label")
        .attr("x", width * .99)
        .attr("y", -6)
        .style("text-anchor", "end")
        .text("Grades");

      focus.append("g")
        .attr("class", "y axis")
        .call(yAxis)
        .append("text")
        .attr("class", "y label")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".75em")
        .style("text-anchor", "end")
        .text("Probability of having a good grade");

      context.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height2 + ")")
        .call(xAxis2)
        .append("text")
        .attr("class", "x label")
        .attr("x", width * .99)
        .attr("y", -6)
        .style("text-anchor", "end")
        .text("Grades");

      context.append("g")
        .attr("class", "x brush")
        .call(brush)
        .selectAll("rect")
        .attr("y", 15)
        .attr("height", height2 - 25);

      // THIS CODE SHOWS THE VALUES OM THE LINE    
      var bisectBMI = d3.bisector(function (d) { return d.grade; }).left
      var formatProb = d3.format(",.2f")
      var formatBMI = d3.format(",.1f")
      var three_paths = focus.selectAll("path.focusdata")[0];

      var focusMarkers = focus.append("g")
        .attr("class", "focusMarkers")
        .style("display", "none");

      focusMarkers.selectAll("g")
        .data(pdata)
        .enter()
        .append("g")
        .attr("id", function (d, i) {
          return "focusMarker_" + d;
        })
        .append("circle")
        .attr("r", 10)

      focusMarkers.select("g").append("text")
        .attr("x", -250)
        .attr("y", 35 - 50)
        .attr("dy", ".35em")
        .attr("id", "prob_circle_label")
        .attr("stroke", "black")
        .attr("stroke-width", "1px");

      focusMarkers.select("g").append("text")
        .attr("x", -250)
        .attr("y", 0 - 50)
        .attr("dy", ".35em")
        .attr("id", "prob_5_circle_label")
        .attr("stroke", "black")
        .attr("stroke-width", "1px");

      focusMarkers.select("g").append("text")
        .attr("x", -250)
        .attr("y", -35 - 50)
        .attr("dy", ".35em")
        .attr("id", "prob_15_circle_label")
        .attr("stroke", "black")
        .attr("stroke-width", "1px");

      focus.append("rect")
        .attr("class", "overlay")
        .attr("width", width)
        .attr("height", height)
        .on("mouseover", function () { focusMarkers.style("display", null); })
        .on("mouseout", function () { focusMarkers.style("display", "none"); })
        .on("mousemove", mousemove);

      var verticalLine = focus.append('line')

        .attr({
          'x1': 0,
          'y1': 0,
          'x2': 0,
          'y2': height
        })
        .attr("stroke", "steelblue")
        .attr('class', 'verticalLine');

      function mousemove() {

        var x0 = xmain.invert(d3.mouse(this)[0]),
          i = bisectBMI(data, x0, 1),
          d0 = data[i - 1],
          d1 = data[i],
          d = x0 - d0.grade > d1.grade - x0 ? d1 : d0;

        xLoc = xmain(d.grade)

        focusMarkers.select("#focusMarker_prob")
          .attr("transform", "translate(" + xLoc + "," + ymain(d.prob) + ")");

        focusMarkers.select("#prob_circle_label")
          .text("Current Risk: " + formatProb(d.prob));


        d3.select(".verticalLine").attr("transform", function () {
          return "translate(" + xLoc + ",0)";
        });

      }
    })

  </script>
</body>

  {% endblock %}